use super::{config::CatalogConfig, FromTrinoCatalogError, ToCatalogConfig};
use async_trait::async_trait;
use stackable_operator::client::Client;
use stackable_trino_crd::catalog::iceberg::IcebergConnector;

pub const CONNECTOR_NAME: &str = "iceberg";

#[async_trait]
impl ToCatalogConfig for IcebergConnector {
    async fn to_catalog_config(
        &self,
        catalog_name: &str,
        catalog_namespace: Option<String>,
        client: &Client,
    ) -> Result<CatalogConfig, FromTrinoCatalogError> {
        // Get config that is generated by attributed shared between Hive and Iceberg
        let mut config = self
            .common
            .to_catalog_config(catalog_name, catalog_namespace, client)
            .await?;

        // As the `HiveAndIcebergCommonAttributes` struct can't know for which connector it is called
        // we have to overwrite the connector name here
        config.add_property("connector.name", CONNECTOR_NAME);

        // No authorization checks are enforced at the catalog level.
        // We don't want the hive connector to prevent users from dropping tables.
        // We also don't want that the hive connector makes decisions on which user is allowed to do what.
        // This decision should be done globally (for all catalogs) by OPA.
        // See https://trino.io/docs/current/connector/hive-security.html
        config.add_property("iceberg.security", "allow-all");

        Ok(config)
    }
}
